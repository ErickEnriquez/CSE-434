#include <sys/select.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <iostream>

using namespace std;

struct header {

    char magic1;
    char magic2;
    char opcode;
    char payload_len;

    uint32_t token;
    uint32_t msg_id;
};

const int h_size = sizeof(struct header);

// These are the constants indicating the states.
#define STATE_OFFLINE          0
#define STATE_LOGIN_SENT       1
#define STATE_ONLINE           2
#define STATE_POST_SENT        3
#define STATE_LOGOUT_SENT      4
#define STATE_SUBSCRIBE_SENT   5
#define STATE_UNSUBCRIBE_SENT  6
#define STATE_RETRIEVE_SENT    7
// Now you can define other states in a similar fashion.

// These are the constants indicating the events.
// All events starting with EVENT_USER_ are generated by a human user.
#define EVENT_USER_LOGIN               0
#define EVENT_USER_POST                1
#define EVENT_USER_LOGOUT              2
#define EVENT_USER_SUBSCRIBE           3
#define EVENT_USER_UNSUBCRIBE          4
#define EVENT_USER_RETRIEVE            5
#define EVENT_INVALID_COMMAND          6
// Now you can define other events from the user.
//......
#define EVENT_USER_INVALID             79
#define EVENT_USER_INVALID_2           78

// All events starting with EVENT_NET_ are generated by receiving a msg
// from the network. We deliberately use larger numbers to help debug.
#define EVENT_NET_LOGIN_SUCCESSFUL      80
#define EVENT_NET_POST_ACK              81
#define EVENT_NET_LOGIN_FAILED          82
#define EVENT_NET_FORWARD               83
#define EVENT_NET_LOGOUT_SUCCESSFUL     84
#define EVENT_NET_SUBSCRIBE_ACK         85
#define EVENT_NET_SUBSCRIBE_FAIL        86
#define EVENT_NET_UNSUBCRIBE_ACK        87
#define EVENT_NET_UNSUBSCRIBE_FAIL      88
#define EVENT_NET_RETRIEVE              89
#define EVENT_NET_RETRIEVE_END          90
#define EVENT_NET_RESET                 91
// Now you can define other events from the network.
//......
#define EVENT_NET_INVALID               255
#define EVENT_USER_RESET                69
#define EVENT_NET_SPECIAL               66

// These are the constants indicating the opcodes.
#define OPCODE_RESET                    0x00
#define OPCODE_MUST_LOGIN_FIRST_ERROR   0x7C
#define OPCODE_LOGIN                    0x10
#define OPCODE_SUCCESSFUL_LOGIN_ACK     0x7E
#define OPCODE_FAILED_LOGIN_ACK         0x7F
#define OPCODE_POST                     0x30
#define OPCODE_POST_ACK                 0x7D
#define OPCODE_SUBSCRIBE_REQUEST        0x7B
#define OPCODE_UNSUBSCRIBE_REQUEST      0x7A
#define OPCODE_SUBSCRIBE_SUCCESS        0x79
#define OPCODE_SUBSCRIBE_FAILURE        0x78
#define OPCODE_UNSUBSCRIBE_SUCCESS      0x77
#define OPCODE_UNSUBSCRIBE_FAILURE      0x76
#define OPCODE_FORWARD                  0x75
#define OPCODE_FORWARD_ACK              0x74
#define OPCODE_RETRIEVE                 0x73
#define OPCODE_RETRIEVE_ACK             0x72
#define OPCODE_END_OF_RETRIEVE_ACK      0x71
#define OPCODE_LOGOUT                   0x70
#define OPCODE_LOGOUT_SUCCESS           0x6F
// Now you can define other opcodes in a similar fashion.
//......
#define MAGIC_1                          'E'
#define MAGIC_2                          'E'

int parse_the_event_from_the_input_string(char*);
int parse_the_event_from_the_received_message(char*);
void send_reset(int, char*);

int main() {

    char user_input[1024];

    int ret;
    int sockfd = 0;
    char send_buffer[1024];
    char recv_buffer[1024];
    struct sockaddr_in serv_addr;
    struct sockaddr_in my_addr;
    int maxfd;
    fd_set read_set;
    FD_ZERO(&read_set);


    // You just need one socket file descriptor. I made a mistake previously
    // and defined two socket file descriptors.
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0) {
	printf("socket() error: %s.\n", strerror(errno));
        return -1;
    }

    // The "serv_addr" is the server's address and port number, 
    // i.e, the destination address if the client needs to send something. 
    // Note that this "serv_addr" must match with the address in the 
    // "UDP receive" code.
    // We assume the server is also running on the same machine, and 
    // hence, the IP address of the server is just "127.0.0.1".
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    serv_addr.sin_port = htons(32000);

    // The "my_addr" is the client's address and port number used for  
    // receiving responses from the server.
    // Note that this is a local address, not a remote address.
    memset(&my_addr, 0, sizeof(my_addr));
    my_addr.sin_family = AF_INET;
    my_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    my_addr.sin_port = htons(82000);


    // Bind "my_addr" to the socket for receiving messages from the server.
    bind(sockfd, 
         (struct sockaddr *) &my_addr, 
         sizeof(my_addr));

    maxfd = sockfd + 1; // Note that the file descriptor of stdin is "0"
    
    int state = STATE_OFFLINE;
    int event;
    uint32_t token = 0; // Assume the token is a 32-bit integer

    // This is a pointer of the type "struct header" but it always points
    // to the first byte of the "send_buffer", i.e., if we dereference this
    // pointer, we get the first 12 bytes in the "send_buffer" in the format
    // of the structure, which is very convenient.
    struct header *ph_send = (struct header *)send_buffer;
    // So as the receive buffer.
    struct header *ph_recv = (struct header *)recv_buffer;
    printf("client running\n");
    while (1) {
        
        // Use select to wait on keyboard input or socket receiving.
        FD_SET(fileno(stdin), &read_set);
        FD_SET(sockfd, &read_set);

        select(maxfd, &read_set, NULL, NULL, NULL);

        if (FD_ISSET(fileno(stdin), &read_set)) {
           
            // Now we know there is a keyboard input event
            // TODO: Figure out which event and process it according to the
            // current state

            fgets(user_input, sizeof(user_input), stdin);

            // Note that in this parse function, you need to check the
            // user input and figure out what event it is. Basically it
            // will be a long sequence of if (strncmp(user_input, ...) == 0)
            // and if none of the "if" matches, return EVENT_USER_INVALID
            event = parse_the_event_from_the_input_string(user_input);
          // cout << "EVENT IS " << event << endl;
            // You can also add a line to print the "event" for debugging.

		if (event == EVENT_USER_LOGIN) {
            	    if (state == STATE_OFFLINE) {
                        
                    // CAUTION: we do not need to parse the user ID and
                    // and password string, assuming they are always in the
                    // correct format. The server will parse it anyway.
                    
                    char *id_password = user_input + 6; // skip the "login#"
                    int m = strlen(id_password);
    
                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_LOGIN;
                    ph_send->payload_len = m;
                    ph_send->token = 0;
                    ph_send->msg_id = 0;

                    memcpy(send_buffer + h_size, id_password, m);
                    sendto(sockfd, send_buffer, h_size + m, 0, 
                        (struct sockaddr *) &serv_addr, sizeof(serv_addr));

                    // Once the corresponding action finishes, transit to
                    // the login_sent state
            	        state = STATE_LOGIN_SENT;
                        
                } else {

                    // TODO: handle errors if the event happens in a state
                    // that is not expected. Basically just print an error
                    // message and doing nothing. Note that if a user types
                    // something invalid, it does not need to trigger a 
                    // session reset.
                    printf("INVALID\n");

                }

            } else if (event == EVENT_USER_POST) {

                    // Note that this is similar to the login msg.
                    // Actually, these messages are carefully designed to 
                    // somewhat minimize the processing on the client side.
                    // If you look at the "subscribe", "unsubscribe", "post"
                    // and "retrieve", they are all similar, i.e., just fill
                    // the header and copy the user input after the "#" as
                    // the payload of the message, then just send the msg.

                    char *text = user_input + 5; // skip the "post#"
                  
                    int m = strlen(text);

                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_POST;
                    ph_send->payload_len = m;
                    ph_send->token = token;
                    ph_send->msg_id = 0;

                    memcpy(send_buffer + h_size, text, m);
                    
                    sendto(sockfd, send_buffer, h_size + m, 0, 
                        (struct sockaddr *) &serv_addr, sizeof(serv_addr));

                    state = STATE_POST_SENT;
                    
            } else if (event == EVENT_USER_RESET) {
                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_RESET;
                    ph_send->payload_len = 0;
                    ph_send->token = token;
                    ph_send->msg_id = 0;
                    sendto(sockfd, send_buffer, h_size, 0, 
                        (struct sockaddr *) &serv_addr, sizeof(serv_addr));
                    state = STATE_OFFLINE;
                    cout << "SESSIONS RESET BY CLIENT";
                // TODO: You may add another command like "reset#" so as to
                // facilitate testing. In this case, a user just need to 
                // type this line to generate a reset message.

                // You can add more commands as you like to help debugging.
                // For example, I can add a command "state#" to instruct the
                // client program to print the current state without chang
                // -ing anything.


            } else if(event == EVENT_USER_LOGOUT){
                if(state == STATE_ONLINE){
                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_LOGOUT;
                    ph_send->payload_len = 0;
                    ph_send->token = token;
                    ph_send->msg_id = 0;
                    
                    sendto(sockfd, send_buffer, h_size , 0, 
                        (struct sockaddr *) &serv_addr, sizeof(serv_addr));

                   state = STATE_LOGOUT_SENT;
                  

                }
                else{
                    cout<< "error#must_login_first\n";
                }

            }
            else if(event == EVENT_USER_SUBSCRIBE){
                
                    char* client = user_input + 10;// skip the subscribe#
                    int m  = strlen(client);

                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_SUBSCRIBE_REQUEST;
                    ph_send->payload_len = m;
                    ph_send->token = token;
                    ph_send->msg_id = 0;

                    memcpy(send_buffer + h_size, client, m);
                    
                    sendto(sockfd, send_buffer, h_size + m, 0, 
                        (struct sockaddr *) &serv_addr, sizeof(serv_addr));

                    state = STATE_SUBSCRIBE_SENT;
                
            }
            else if(event ==  EVENT_USER_UNSUBCRIBE){
                    char* client = user_input + 12;// skip the unsubscribe#
                    int m  = strlen(client);

                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_UNSUBSCRIBE_REQUEST;
                    ph_send->payload_len = m;
                    ph_send->token = token;
                    ph_send->msg_id = 0;

                    memcpy(send_buffer + h_size, client, m);
                    
                    sendto(sockfd, send_buffer, h_size + m, 0, 
                        (struct sockaddr *) &serv_addr, sizeof(serv_addr));

                    state = STATE_UNSUBCRIBE_SENT;
                
            }
            else if(event  == EVENT_USER_RETRIEVE){
                    bool is_a_number = true; //check if value is a number
                    char* number = user_input + 9; //skip the retrieve
                    int m = strlen(number);
                    for(int i = 0 ; i < strlen(number) -1 ; i++){
                        if(isdigit(number[i]) == false){
                            send_reset(sockfd, send_buffer);
                            is_a_number = false;
                        }
                    }
                    if(is_a_number == true){//if we have a valid number
                     ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_RETRIEVE;
                    ph_send->payload_len = m;
                    ph_send->token = token;
                    ph_send->msg_id = 0;

                    memcpy(send_buffer + h_size, number, m);
                    
                    sendto(sockfd, send_buffer, h_size + m, 0, 
                        (struct sockaddr *) &serv_addr, sizeof(serv_addr));

                    state = STATE_RETRIEVE_SENT;//put client in retrieve sent state
                    cout <<"RETRIEVE SENT\n";
                    }
                    else
                        cout <<"NOT A NUMBER";
                
            }
            else if(event == EVENT_USER_INVALID ){//user enters something invalid
                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = 0x5C; //INVALID OPCODE
                    ph_send->payload_len = 0;
                    ph_send->token = token;
                    ph_send->msg_id = 0;

                    sendto(sockfd, send_buffer, h_size, 0, 
                        (struct sockaddr *) &serv_addr, sizeof(serv_addr));//SEND THE SPURRIOUS MESSAGE
               //     cout << "SENT MESSAGE\n";

                
            }
            else if(event == EVENT_USER_INVALID_2){//getting server to send back something invalid
                ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = 0x5D; //special opcode for server
                    ph_send->payload_len = 0;
                    ph_send->token = token;
                    ph_send->msg_id = 0;

                    sendto(sockfd, send_buffer, h_size, 0, 
                        (struct sockaddr *) &serv_addr, sizeof(serv_addr));//SEND THE SPURRIOUS MESSAGE
            }
            else if(event == EVENT_INVALID_COMMAND){
                cout << "INVALID COMMAND PLEASE TRY AGAIN\n";
            }

        }
        if (FD_ISSET(sockfd, &read_set)) {
           //  cout <<"network event\n\n";
            // Now we know there is an event from the network
            // TODO: Figure out which event and process it according to the
            // current state

            ret = recv(sockfd, recv_buffer, sizeof(recv_buffer), 0);
          
            event = parse_the_event_from_the_received_message(recv_buffer);
        //    cout << "EVENT IS " << event <<endl;
        //   printf("OPCODE IS %x \n",recv_buffer[2]);
            if (event == EVENT_NET_LOGIN_SUCCESSFUL) {
            	    if (state == STATE_LOGIN_SENT) {

                    token = ph_recv->token;

                    // TODO: print a line of "login_ack#successful"
                    state = STATE_ONLINE;
                    cout << "login_ack#successful\n";
                    

                } else {

                    // A spurious msg is received. Just reset the session.
                    // You can define a function "send_reset()" for 
                    // convenience because it might be used in many places.
                    send_reset(sockfd, send_buffer);

                    state = STATE_OFFLINE;
                }
            } else if (event == EVENT_NET_LOGIN_FAILED) {
            	    if (state == STATE_LOGIN_SENT) {

                    // TODO: print a line of "login_ack#failed"
                    state = STATE_OFFLINE;
                    cout << "login_ack#failed\n";

                } else {

                    send_reset(sockfd, send_buffer);

                    state = STATE_OFFLINE;
                }

            } else if (event == EVENT_NET_FORWARD) {
               
            	    if (state == STATE_ONLINE) {
                    // Just extract the payload and print the text.
                    char *text = recv_buffer + h_size;

                    printf("%s\n", text);

                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_FORWARD_ACK;
                    ph_send->payload_len = 0;
                    ph_send->token = token;
                    ph_send->msg_id = 0;

                    sendto(sockfd, send_buffer, h_size, 0, 
                        (struct sockaddr *) &serv_addr, sizeof(serv_addr));



                    // Note that no state change is needed.

                } else {

                    send_reset(sockfd,send_buffer);//there has been error reset connection
                }
            
           }
           else if(event == EVENT_NET_POST_ACK){//acknowlegment of successful post
                if(state == STATE_POST_SENT){
                    cout << "post_ack#successful\n";
                    state = STATE_ONLINE;
                }
                else{
                    cout << "ERROR YOU ARE NOT IN RIGHT STATE";
                    state = STATE_OFFLINE;
                    //send_reset();
                }
                
           }
           else if(event == EVENT_NET_INVALID){
               cout << "error#must_login_first\n";
               state = STATE_OFFLINE;
           }
           else if(event == EVENT_NET_LOGOUT_SUCCESSFUL){
               cout<<"logout_ack#successful​\n";
               state = STATE_OFFLINE;

           }
           else if(event == EVENT_NET_SUBSCRIBE_ACK){
               if(state == STATE_SUBSCRIBE_SENT){
                   cout<< "subscribe_ack#successful​\n";
                   state = STATE_ONLINE;
               }
           }
           else if(event == EVENT_NET_SUBSCRIBE_FAIL){
               if(state == STATE_SUBSCRIBE_SENT){
                   cout<<"subscribe_ack#failed\n";
                   state = STATE_ONLINE;
               }
           }
           else if(event == EVENT_NET_UNSUBCRIBE_ACK){
               if(state == STATE_UNSUBCRIBE_SENT){
                   cout << "unsubscribe_ack#successful​\n";
                   state = STATE_ONLINE;
               }
           }
           else if(event == EVENT_NET_UNSUBSCRIBE_FAIL){
               if(state == STATE_UNSUBCRIBE_SENT){
                   cout << "unsubscribe_ack#failed\n";
                   state = STATE_ONLINE;
               }
           }
           else if(event == EVENT_NET_RETRIEVE){
               if(state == STATE_RETRIEVE_SENT){
                   char *text = recv_buffer + h_size;

                    printf("%s\n", text);
               }
           }
           else if(event == EVENT_NET_RETRIEVE_END){
               if(state == STATE_RETRIEVE_SENT){
                   cout << "DONE RECIEVING\n";
                   state = STATE_ONLINE;
               }
           }
           else if(event == EVENT_NET_RESET){
               state = STATE_OFFLINE;
               cout << "SESSIONS RESET BY SERVER\n";
           }
           else if(event == EVENT_NET_SPECIAL){//if the server sends an invalid response
                cout << "INVALID SERVER RESPONSE SESSION RESET\n";
                state = STATE_OFFLINE;
                ph_send->magic1 = MAGIC_1;
                ph_send->magic2 = MAGIC_2;
                ph_send->opcode = OPCODE_RESET;
                ph_send->payload_len = 0;
                ph_send->token = token;
                ph_send->msg_id = 0;

                sendto(sockfd, send_buffer, h_size, 0, 
                     (struct sockaddr *) &serv_addr, sizeof(serv_addr));
           }
           





        }//

        // Now we finished processing the pending event. Just go back to the
        // beginning of the loop and waiting for another event. 
        // Note that you can set a timeout for the select() function 
        // to allow it to return regularly and check timeout related events.
        bzero(recv_buffer,1024);//clean the buffer out every time
       
    } // This is the end of the while loop


} // This is the end of main()

int parse_the_event_from_the_input_string(char* input){
    if(strncmp(input,"login#",strlen("login#")) == 0){
        return EVENT_USER_LOGIN;
   }
    else if(strncmp(input,"post#",strlen("post#")) == 0){
        return EVENT_USER_POST;
    }
    else if(strncmp(input,"logout#",strlen("logout#")) == 0){
        return EVENT_USER_LOGOUT;
    }
    else if(strncmp(input,"subscribe#",strlen("subscribe#")) == 0){
        return EVENT_USER_SUBSCRIBE;
    }
    else if(strncmp(input,"unsubscribe#",strlen("unsubscribe#"))==0){
        return EVENT_USER_UNSUBCRIBE;
    }
    else if(strncmp(input,"retrieve#",strlen("retrieve#")) == 0){
        return EVENT_USER_RETRIEVE;
    }
    else if(strncmp(input,"spurious#",strlen("spurious#")) == 0){
        return EVENT_USER_INVALID;//returns invalid code
    }
    else if(strncmp(input,"spurious2#",strlen("spurious#2")) == 0){
        return EVENT_USER_INVALID_2;
    }
    else
    {
        return EVENT_INVALID_COMMAND;
    }
    
}

int parse_the_event_from_the_received_message(char* message){
    if(message[2] == OPCODE_FAILED_LOGIN_ACK)
        return EVENT_NET_LOGIN_FAILED;
    else if(message[2] == OPCODE_SUCCESSFUL_LOGIN_ACK)
        return EVENT_NET_LOGIN_SUCCESSFUL;
    else if(message[2] == OPCODE_POST_ACK)
        return EVENT_NET_POST_ACK;
    else if(message[2]==  OPCODE_MUST_LOGIN_FIRST_ERROR)
        return EVENT_NET_INVALID;
    else if(message[2] == OPCODE_LOGOUT_SUCCESS)
        return EVENT_NET_LOGOUT_SUCCESSFUL;
    else if(message[2] == OPCODE_SUBSCRIBE_SUCCESS)
        return EVENT_NET_SUBSCRIBE_ACK;
    else if(message[2] == OPCODE_SUBSCRIBE_FAILURE)
        return EVENT_NET_SUBSCRIBE_FAIL;
    else if(message[2] == OPCODE_UNSUBSCRIBE_SUCCESS)
        return EVENT_NET_UNSUBCRIBE_ACK;
    else if(message[2] == OPCODE_UNSUBSCRIBE_FAILURE)
        return EVENT_NET_UNSUBSCRIBE_FAIL;
    else if(message[2] == OPCODE_FORWARD)
        return EVENT_NET_FORWARD;
    else if(message[2] == OPCODE_RETRIEVE_ACK)
        return EVENT_NET_RETRIEVE;
    else if(message[2]== OPCODE_END_OF_RETRIEVE_ACK)
        return EVENT_NET_RETRIEVE_END;
    else if(message[2]== OPCODE_RESET)
        return EVENT_NET_RESET;
    else
    {
        return EVENT_NET_SPECIAL;// invalid command
    }
}
void send_reset(int, char*){
    return;
}


